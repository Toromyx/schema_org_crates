use super::*;
/// <https://schema.org/MedicalCondition>
#[cfg_attr(feature = "derive-debug", derive(Debug))]
#[cfg_attr(feature = "derive-clone", derive(Clone))]
pub struct MedicalCondition {
	/// <https://schema.org/associatedAnatomy>
	pub r#associated_anatomy: Vec<AssociatedAnatomyProperty>,
	/// <https://schema.org/differentialDiagnosis>
	pub r#differential_diagnosis: Vec<DifferentialDiagnosisProperty>,
	/// <https://schema.org/drug>
	pub r#drug: Vec<DrugProperty>,
	/// <https://schema.org/epidemiology>
	pub r#epidemiology: Vec<EpidemiologyProperty>,
	/// <https://schema.org/expectedPrognosis>
	pub r#expected_prognosis: Vec<ExpectedPrognosisProperty>,
	/// <https://schema.org/naturalProgression>
	pub r#natural_progression: Vec<NaturalProgressionProperty>,
	/// <https://schema.org/pathophysiology>
	pub r#pathophysiology: Vec<PathophysiologyProperty>,
	/// <https://schema.org/possibleComplication>
	pub r#possible_complication: Vec<PossibleComplicationProperty>,
	/// <https://schema.org/possibleTreatment>
	pub r#possible_treatment: Vec<PossibleTreatmentProperty>,
	/// <https://schema.org/primaryPrevention>
	pub r#primary_prevention: Vec<PrimaryPreventionProperty>,
	/// <https://schema.org/riskFactor>
	pub r#risk_factor: Vec<RiskFactorProperty>,
	/// <https://schema.org/secondaryPrevention>
	pub r#secondary_prevention: Vec<SecondaryPreventionProperty>,
	/// <https://schema.org/signOrSymptom>
	pub r#sign_or_symptom: Vec<SignOrSymptomProperty>,
	/// <https://schema.org/stage>
	pub r#stage: Vec<StageProperty>,
	/// <https://schema.org/status>
	pub r#status: Vec<StatusProperty>,
	/// <https://schema.org/typicalTest>
	pub r#typical_test: Vec<TypicalTestProperty>,
	/// <https://schema.org/code>
	pub r#code: Vec<CodeProperty>,
	/// <https://schema.org/funding>
	pub r#funding: Vec<FundingProperty>,
	/// <https://schema.org/guideline>
	pub r#guideline: Vec<GuidelineProperty>,
	/// <https://schema.org/legalStatus>
	pub r#legal_status: Vec<LegalStatusProperty>,
	/// <https://schema.org/medicineSystem>
	pub r#medicine_system: Vec<MedicineSystemProperty>,
	/// <https://schema.org/recognizingAuthority>
	pub r#recognizing_authority: Vec<RecognizingAuthorityProperty>,
	/// <https://schema.org/relevantSpecialty>
	pub r#relevant_specialty: Vec<RelevantSpecialtyProperty>,
	/// <https://schema.org/study>
	pub r#study: Vec<StudyProperty>,
	/// <https://schema.org/additionalType>
	pub r#additional_type: Vec<AdditionalTypeProperty>,
	/// <https://schema.org/alternateName>
	pub r#alternate_name: Vec<AlternateNameProperty>,
	/// <https://schema.org/description>
	pub r#description: Vec<DescriptionProperty>,
	/// <https://schema.org/disambiguatingDescription>
	pub r#disambiguating_description: Vec<DisambiguatingDescriptionProperty>,
	/// <https://schema.org/identifier>
	pub r#identifier: Vec<IdentifierProperty>,
	/// <https://schema.org/image>
	pub r#image: Vec<ImageProperty>,
	/// <https://schema.org/mainEntityOfPage>
	pub r#main_entity_of_page: Vec<MainEntityOfPageProperty>,
	/// <https://schema.org/name>
	pub r#name: Vec<NameProperty>,
	/// <https://schema.org/potentialAction>
	pub r#potential_action: Vec<PotentialActionProperty>,
	/// <https://schema.org/sameAs>
	pub r#same_as: Vec<SameAsProperty>,
	/// <https://schema.org/subjectOf>
	pub r#subject_of: Vec<SubjectOfProperty>,
	/// <https://schema.org/url>
	pub r#url: Vec<UrlProperty>,
}
/// This trait is for properties from <https://schema.org/MedicalCondition>.
pub trait MedicalConditionTrait {
	/// Get <https://schema.org/associatedAnatomy> from [`Self`] as borrowed slice.
	fn get_associated_anatomy(&self) -> &[AssociatedAnatomyProperty];
	/// Take <https://schema.org/associatedAnatomy> from [`Self`] as owned vector.
	fn take_associated_anatomy(&mut self) -> Vec<AssociatedAnatomyProperty>;
	/// Get <https://schema.org/differentialDiagnosis> from [`Self`] as borrowed slice.
	fn get_differential_diagnosis(&self) -> &[DifferentialDiagnosisProperty];
	/// Take <https://schema.org/differentialDiagnosis> from [`Self`] as owned vector.
	fn take_differential_diagnosis(&mut self) -> Vec<DifferentialDiagnosisProperty>;
	/// Get <https://schema.org/drug> from [`Self`] as borrowed slice.
	fn get_drug(&self) -> &[DrugProperty];
	/// Take <https://schema.org/drug> from [`Self`] as owned vector.
	fn take_drug(&mut self) -> Vec<DrugProperty>;
	/// Get <https://schema.org/epidemiology> from [`Self`] as borrowed slice.
	fn get_epidemiology(&self) -> &[EpidemiologyProperty];
	/// Take <https://schema.org/epidemiology> from [`Self`] as owned vector.
	fn take_epidemiology(&mut self) -> Vec<EpidemiologyProperty>;
	/// Get <https://schema.org/expectedPrognosis> from [`Self`] as borrowed slice.
	fn get_expected_prognosis(&self) -> &[ExpectedPrognosisProperty];
	/// Take <https://schema.org/expectedPrognosis> from [`Self`] as owned vector.
	fn take_expected_prognosis(&mut self) -> Vec<ExpectedPrognosisProperty>;
	/// Get <https://schema.org/naturalProgression> from [`Self`] as borrowed slice.
	fn get_natural_progression(&self) -> &[NaturalProgressionProperty];
	/// Take <https://schema.org/naturalProgression> from [`Self`] as owned vector.
	fn take_natural_progression(&mut self) -> Vec<NaturalProgressionProperty>;
	/// Get <https://schema.org/pathophysiology> from [`Self`] as borrowed slice.
	fn get_pathophysiology(&self) -> &[PathophysiologyProperty];
	/// Take <https://schema.org/pathophysiology> from [`Self`] as owned vector.
	fn take_pathophysiology(&mut self) -> Vec<PathophysiologyProperty>;
	/// Get <https://schema.org/possibleComplication> from [`Self`] as borrowed slice.
	fn get_possible_complication(&self) -> &[PossibleComplicationProperty];
	/// Take <https://schema.org/possibleComplication> from [`Self`] as owned vector.
	fn take_possible_complication(&mut self) -> Vec<PossibleComplicationProperty>;
	/// Get <https://schema.org/possibleTreatment> from [`Self`] as borrowed slice.
	fn get_possible_treatment(&self) -> &[PossibleTreatmentProperty];
	/// Take <https://schema.org/possibleTreatment> from [`Self`] as owned vector.
	fn take_possible_treatment(&mut self) -> Vec<PossibleTreatmentProperty>;
	/// Get <https://schema.org/primaryPrevention> from [`Self`] as borrowed slice.
	fn get_primary_prevention(&self) -> &[PrimaryPreventionProperty];
	/// Take <https://schema.org/primaryPrevention> from [`Self`] as owned vector.
	fn take_primary_prevention(&mut self) -> Vec<PrimaryPreventionProperty>;
	/// Get <https://schema.org/riskFactor> from [`Self`] as borrowed slice.
	fn get_risk_factor(&self) -> &[RiskFactorProperty];
	/// Take <https://schema.org/riskFactor> from [`Self`] as owned vector.
	fn take_risk_factor(&mut self) -> Vec<RiskFactorProperty>;
	/// Get <https://schema.org/secondaryPrevention> from [`Self`] as borrowed slice.
	fn get_secondary_prevention(&self) -> &[SecondaryPreventionProperty];
	/// Take <https://schema.org/secondaryPrevention> from [`Self`] as owned vector.
	fn take_secondary_prevention(&mut self) -> Vec<SecondaryPreventionProperty>;
	/// Get <https://schema.org/signOrSymptom> from [`Self`] as borrowed slice.
	fn get_sign_or_symptom(&self) -> &[SignOrSymptomProperty];
	/// Take <https://schema.org/signOrSymptom> from [`Self`] as owned vector.
	fn take_sign_or_symptom(&mut self) -> Vec<SignOrSymptomProperty>;
	/// Get <https://schema.org/stage> from [`Self`] as borrowed slice.
	fn get_stage(&self) -> &[StageProperty];
	/// Take <https://schema.org/stage> from [`Self`] as owned vector.
	fn take_stage(&mut self) -> Vec<StageProperty>;
	/// Get <https://schema.org/status> from [`Self`] as borrowed slice.
	fn get_status(&self) -> &[StatusProperty];
	/// Take <https://schema.org/status> from [`Self`] as owned vector.
	fn take_status(&mut self) -> Vec<StatusProperty>;
	/// Get <https://schema.org/typicalTest> from [`Self`] as borrowed slice.
	fn get_typical_test(&self) -> &[TypicalTestProperty];
	/// Take <https://schema.org/typicalTest> from [`Self`] as owned vector.
	fn take_typical_test(&mut self) -> Vec<TypicalTestProperty>;
}
impl MedicalConditionTrait for MedicalCondition {
	fn get_associated_anatomy(&self) -> &[AssociatedAnatomyProperty] {
		self.r#associated_anatomy.as_slice()
	}
	fn take_associated_anatomy(&mut self) -> Vec<AssociatedAnatomyProperty> {
		std::mem::take(&mut self.r#associated_anatomy)
	}
	fn get_differential_diagnosis(&self) -> &[DifferentialDiagnosisProperty] {
		self.r#differential_diagnosis.as_slice()
	}
	fn take_differential_diagnosis(&mut self) -> Vec<DifferentialDiagnosisProperty> {
		std::mem::take(&mut self.r#differential_diagnosis)
	}
	fn get_drug(&self) -> &[DrugProperty] {
		self.r#drug.as_slice()
	}
	fn take_drug(&mut self) -> Vec<DrugProperty> {
		std::mem::take(&mut self.r#drug)
	}
	fn get_epidemiology(&self) -> &[EpidemiologyProperty] {
		self.r#epidemiology.as_slice()
	}
	fn take_epidemiology(&mut self) -> Vec<EpidemiologyProperty> {
		std::mem::take(&mut self.r#epidemiology)
	}
	fn get_expected_prognosis(&self) -> &[ExpectedPrognosisProperty] {
		self.r#expected_prognosis.as_slice()
	}
	fn take_expected_prognosis(&mut self) -> Vec<ExpectedPrognosisProperty> {
		std::mem::take(&mut self.r#expected_prognosis)
	}
	fn get_natural_progression(&self) -> &[NaturalProgressionProperty] {
		self.r#natural_progression.as_slice()
	}
	fn take_natural_progression(&mut self) -> Vec<NaturalProgressionProperty> {
		std::mem::take(&mut self.r#natural_progression)
	}
	fn get_pathophysiology(&self) -> &[PathophysiologyProperty] {
		self.r#pathophysiology.as_slice()
	}
	fn take_pathophysiology(&mut self) -> Vec<PathophysiologyProperty> {
		std::mem::take(&mut self.r#pathophysiology)
	}
	fn get_possible_complication(&self) -> &[PossibleComplicationProperty] {
		self.r#possible_complication.as_slice()
	}
	fn take_possible_complication(&mut self) -> Vec<PossibleComplicationProperty> {
		std::mem::take(&mut self.r#possible_complication)
	}
	fn get_possible_treatment(&self) -> &[PossibleTreatmentProperty] {
		self.r#possible_treatment.as_slice()
	}
	fn take_possible_treatment(&mut self) -> Vec<PossibleTreatmentProperty> {
		std::mem::take(&mut self.r#possible_treatment)
	}
	fn get_primary_prevention(&self) -> &[PrimaryPreventionProperty] {
		self.r#primary_prevention.as_slice()
	}
	fn take_primary_prevention(&mut self) -> Vec<PrimaryPreventionProperty> {
		std::mem::take(&mut self.r#primary_prevention)
	}
	fn get_risk_factor(&self) -> &[RiskFactorProperty] {
		self.r#risk_factor.as_slice()
	}
	fn take_risk_factor(&mut self) -> Vec<RiskFactorProperty> {
		std::mem::take(&mut self.r#risk_factor)
	}
	fn get_secondary_prevention(&self) -> &[SecondaryPreventionProperty] {
		self.r#secondary_prevention.as_slice()
	}
	fn take_secondary_prevention(&mut self) -> Vec<SecondaryPreventionProperty> {
		std::mem::take(&mut self.r#secondary_prevention)
	}
	fn get_sign_or_symptom(&self) -> &[SignOrSymptomProperty] {
		self.r#sign_or_symptom.as_slice()
	}
	fn take_sign_or_symptom(&mut self) -> Vec<SignOrSymptomProperty> {
		std::mem::take(&mut self.r#sign_or_symptom)
	}
	fn get_stage(&self) -> &[StageProperty] {
		self.r#stage.as_slice()
	}
	fn take_stage(&mut self) -> Vec<StageProperty> {
		std::mem::take(&mut self.r#stage)
	}
	fn get_status(&self) -> &[StatusProperty] {
		self.r#status.as_slice()
	}
	fn take_status(&mut self) -> Vec<StatusProperty> {
		std::mem::take(&mut self.r#status)
	}
	fn get_typical_test(&self) -> &[TypicalTestProperty] {
		self.r#typical_test.as_slice()
	}
	fn take_typical_test(&mut self) -> Vec<TypicalTestProperty> {
		std::mem::take(&mut self.r#typical_test)
	}
}
impl MedicalEntityTrait for MedicalCondition {
	fn get_code(&self) -> &[CodeProperty] {
		self.r#code.as_slice()
	}
	fn take_code(&mut self) -> Vec<CodeProperty> {
		std::mem::take(&mut self.r#code)
	}
	fn get_funding(&self) -> &[FundingProperty] {
		self.r#funding.as_slice()
	}
	fn take_funding(&mut self) -> Vec<FundingProperty> {
		std::mem::take(&mut self.r#funding)
	}
	fn get_guideline(&self) -> &[GuidelineProperty] {
		self.r#guideline.as_slice()
	}
	fn take_guideline(&mut self) -> Vec<GuidelineProperty> {
		std::mem::take(&mut self.r#guideline)
	}
	fn get_legal_status(&self) -> &[LegalStatusProperty] {
		self.r#legal_status.as_slice()
	}
	fn take_legal_status(&mut self) -> Vec<LegalStatusProperty> {
		std::mem::take(&mut self.r#legal_status)
	}
	fn get_medicine_system(&self) -> &[MedicineSystemProperty] {
		self.r#medicine_system.as_slice()
	}
	fn take_medicine_system(&mut self) -> Vec<MedicineSystemProperty> {
		std::mem::take(&mut self.r#medicine_system)
	}
	fn get_recognizing_authority(&self) -> &[RecognizingAuthorityProperty] {
		self.r#recognizing_authority.as_slice()
	}
	fn take_recognizing_authority(&mut self) -> Vec<RecognizingAuthorityProperty> {
		std::mem::take(&mut self.r#recognizing_authority)
	}
	fn get_relevant_specialty(&self) -> &[RelevantSpecialtyProperty] {
		self.r#relevant_specialty.as_slice()
	}
	fn take_relevant_specialty(&mut self) -> Vec<RelevantSpecialtyProperty> {
		std::mem::take(&mut self.r#relevant_specialty)
	}
	fn get_study(&self) -> &[StudyProperty] {
		self.r#study.as_slice()
	}
	fn take_study(&mut self) -> Vec<StudyProperty> {
		std::mem::take(&mut self.r#study)
	}
}
impl ThingTrait for MedicalCondition {
	fn get_additional_type(&self) -> &[AdditionalTypeProperty] {
		self.r#additional_type.as_slice()
	}
	fn take_additional_type(&mut self) -> Vec<AdditionalTypeProperty> {
		std::mem::take(&mut self.r#additional_type)
	}
	fn get_alternate_name(&self) -> &[AlternateNameProperty] {
		self.r#alternate_name.as_slice()
	}
	fn take_alternate_name(&mut self) -> Vec<AlternateNameProperty> {
		std::mem::take(&mut self.r#alternate_name)
	}
	fn get_description(&self) -> &[DescriptionProperty] {
		self.r#description.as_slice()
	}
	fn take_description(&mut self) -> Vec<DescriptionProperty> {
		std::mem::take(&mut self.r#description)
	}
	fn get_disambiguating_description(&self) -> &[DisambiguatingDescriptionProperty] {
		self.r#disambiguating_description.as_slice()
	}
	fn take_disambiguating_description(&mut self) -> Vec<DisambiguatingDescriptionProperty> {
		std::mem::take(&mut self.r#disambiguating_description)
	}
	fn get_identifier(&self) -> &[IdentifierProperty] {
		self.r#identifier.as_slice()
	}
	fn take_identifier(&mut self) -> Vec<IdentifierProperty> {
		std::mem::take(&mut self.r#identifier)
	}
	fn get_image(&self) -> &[ImageProperty] {
		self.r#image.as_slice()
	}
	fn take_image(&mut self) -> Vec<ImageProperty> {
		std::mem::take(&mut self.r#image)
	}
	fn get_main_entity_of_page(&self) -> &[MainEntityOfPageProperty] {
		self.r#main_entity_of_page.as_slice()
	}
	fn take_main_entity_of_page(&mut self) -> Vec<MainEntityOfPageProperty> {
		std::mem::take(&mut self.r#main_entity_of_page)
	}
	fn get_name(&self) -> &[NameProperty] {
		self.r#name.as_slice()
	}
	fn take_name(&mut self) -> Vec<NameProperty> {
		std::mem::take(&mut self.r#name)
	}
	fn get_potential_action(&self) -> &[PotentialActionProperty] {
		self.r#potential_action.as_slice()
	}
	fn take_potential_action(&mut self) -> Vec<PotentialActionProperty> {
		std::mem::take(&mut self.r#potential_action)
	}
	fn get_same_as(&self) -> &[SameAsProperty] {
		self.r#same_as.as_slice()
	}
	fn take_same_as(&mut self) -> Vec<SameAsProperty> {
		std::mem::take(&mut self.r#same_as)
	}
	fn get_subject_of(&self) -> &[SubjectOfProperty] {
		self.r#subject_of.as_slice()
	}
	fn take_subject_of(&mut self) -> Vec<SubjectOfProperty> {
		std::mem::take(&mut self.r#subject_of)
	}
	fn get_url(&self) -> &[UrlProperty] {
		self.r#url.as_slice()
	}
	fn take_url(&mut self) -> Vec<UrlProperty> {
		std::mem::take(&mut self.r#url)
	}
}
#[cfg(feature = "serde")]
mod serde {
	use std::{fmt, fmt::Formatter};

	use ::serde::{
		de, de::Visitor, ser::SerializeStruct, Deserialize, Deserializer, Serialize, Serializer,
	};

	use super::*;
	impl Serialize for MedicalCondition {
		fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
		where
			S: Serializer,
		{
			let len: usize = [
				!Vec::is_empty(&self.r#associated_anatomy) as usize,
				!Vec::is_empty(&self.r#differential_diagnosis) as usize,
				!Vec::is_empty(&self.r#drug) as usize,
				!Vec::is_empty(&self.r#epidemiology) as usize,
				!Vec::is_empty(&self.r#expected_prognosis) as usize,
				!Vec::is_empty(&self.r#natural_progression) as usize,
				!Vec::is_empty(&self.r#pathophysiology) as usize,
				!Vec::is_empty(&self.r#possible_complication) as usize,
				!Vec::is_empty(&self.r#possible_treatment) as usize,
				!Vec::is_empty(&self.r#primary_prevention) as usize,
				!Vec::is_empty(&self.r#risk_factor) as usize,
				!Vec::is_empty(&self.r#secondary_prevention) as usize,
				!Vec::is_empty(&self.r#sign_or_symptom) as usize,
				!Vec::is_empty(&self.r#stage) as usize,
				!Vec::is_empty(&self.r#status) as usize,
				!Vec::is_empty(&self.r#typical_test) as usize,
				!Vec::is_empty(&self.r#code) as usize,
				!Vec::is_empty(&self.r#funding) as usize,
				!Vec::is_empty(&self.r#guideline) as usize,
				!Vec::is_empty(&self.r#legal_status) as usize,
				!Vec::is_empty(&self.r#medicine_system) as usize,
				!Vec::is_empty(&self.r#recognizing_authority) as usize,
				!Vec::is_empty(&self.r#relevant_specialty) as usize,
				!Vec::is_empty(&self.r#study) as usize,
				!Vec::is_empty(&self.r#additional_type) as usize,
				!Vec::is_empty(&self.r#alternate_name) as usize,
				!Vec::is_empty(&self.r#description) as usize,
				!Vec::is_empty(&self.r#disambiguating_description) as usize,
				!Vec::is_empty(&self.r#identifier) as usize,
				!Vec::is_empty(&self.r#image) as usize,
				!Vec::is_empty(&self.r#main_entity_of_page) as usize,
				!Vec::is_empty(&self.r#name) as usize,
				!Vec::is_empty(&self.r#potential_action) as usize,
				!Vec::is_empty(&self.r#same_as) as usize,
				!Vec::is_empty(&self.r#subject_of) as usize,
				!Vec::is_empty(&self.r#url) as usize,
			]
			.iter()
			.sum();
			let mut serialize_struct =
				Serializer::serialize_struct(serializer, "MedicalCondition", len)?;
			if !Vec::is_empty(&self.r#associated_anatomy) {
				serialize_struct.serialize_field("associatedAnatomy", {
					struct SerializeWith<'a>(&'a Vec<AssociatedAnatomyProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#associated_anatomy)
				})?;
			} else {
				serialize_struct.skip_field("associatedAnatomy")?;
			}
			if !Vec::is_empty(&self.r#differential_diagnosis) {
				serialize_struct.serialize_field("differentialDiagnosis", {
					struct SerializeWith<'a>(&'a Vec<DifferentialDiagnosisProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#differential_diagnosis)
				})?;
			} else {
				serialize_struct.skip_field("differentialDiagnosis")?;
			}
			if !Vec::is_empty(&self.r#drug) {
				serialize_struct.serialize_field("drug", {
					struct SerializeWith<'a>(&'a Vec<DrugProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#drug)
				})?;
			} else {
				serialize_struct.skip_field("drug")?;
			}
			if !Vec::is_empty(&self.r#epidemiology) {
				serialize_struct.serialize_field("epidemiology", {
					struct SerializeWith<'a>(&'a Vec<EpidemiologyProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#epidemiology)
				})?;
			} else {
				serialize_struct.skip_field("epidemiology")?;
			}
			if !Vec::is_empty(&self.r#expected_prognosis) {
				serialize_struct.serialize_field("expectedPrognosis", {
					struct SerializeWith<'a>(&'a Vec<ExpectedPrognosisProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#expected_prognosis)
				})?;
			} else {
				serialize_struct.skip_field("expectedPrognosis")?;
			}
			if !Vec::is_empty(&self.r#natural_progression) {
				serialize_struct.serialize_field("naturalProgression", {
					struct SerializeWith<'a>(&'a Vec<NaturalProgressionProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#natural_progression)
				})?;
			} else {
				serialize_struct.skip_field("naturalProgression")?;
			}
			if !Vec::is_empty(&self.r#pathophysiology) {
				serialize_struct.serialize_field("pathophysiology", {
					struct SerializeWith<'a>(&'a Vec<PathophysiologyProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#pathophysiology)
				})?;
			} else {
				serialize_struct.skip_field("pathophysiology")?;
			}
			if !Vec::is_empty(&self.r#possible_complication) {
				serialize_struct.serialize_field("possibleComplication", {
					struct SerializeWith<'a>(&'a Vec<PossibleComplicationProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#possible_complication)
				})?;
			} else {
				serialize_struct.skip_field("possibleComplication")?;
			}
			if !Vec::is_empty(&self.r#possible_treatment) {
				serialize_struct.serialize_field("possibleTreatment", {
					struct SerializeWith<'a>(&'a Vec<PossibleTreatmentProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#possible_treatment)
				})?;
			} else {
				serialize_struct.skip_field("possibleTreatment")?;
			}
			if !Vec::is_empty(&self.r#primary_prevention) {
				serialize_struct.serialize_field("primaryPrevention", {
					struct SerializeWith<'a>(&'a Vec<PrimaryPreventionProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#primary_prevention)
				})?;
			} else {
				serialize_struct.skip_field("primaryPrevention")?;
			}
			if !Vec::is_empty(&self.r#risk_factor) {
				serialize_struct.serialize_field("riskFactor", {
					struct SerializeWith<'a>(&'a Vec<RiskFactorProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#risk_factor)
				})?;
			} else {
				serialize_struct.skip_field("riskFactor")?;
			}
			if !Vec::is_empty(&self.r#secondary_prevention) {
				serialize_struct.serialize_field("secondaryPrevention", {
					struct SerializeWith<'a>(&'a Vec<SecondaryPreventionProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#secondary_prevention)
				})?;
			} else {
				serialize_struct.skip_field("secondaryPrevention")?;
			}
			if !Vec::is_empty(&self.r#sign_or_symptom) {
				serialize_struct.serialize_field("signOrSymptom", {
					struct SerializeWith<'a>(&'a Vec<SignOrSymptomProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#sign_or_symptom)
				})?;
			} else {
				serialize_struct.skip_field("signOrSymptom")?;
			}
			if !Vec::is_empty(&self.r#stage) {
				serialize_struct.serialize_field("stage", {
					struct SerializeWith<'a>(&'a Vec<StageProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#stage)
				})?;
			} else {
				serialize_struct.skip_field("stage")?;
			}
			if !Vec::is_empty(&self.r#status) {
				serialize_struct.serialize_field("status", {
					struct SerializeWith<'a>(&'a Vec<StatusProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#status)
				})?;
			} else {
				serialize_struct.skip_field("status")?;
			}
			if !Vec::is_empty(&self.r#typical_test) {
				serialize_struct.serialize_field("typicalTest", {
					struct SerializeWith<'a>(&'a Vec<TypicalTestProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#typical_test)
				})?;
			} else {
				serialize_struct.skip_field("typicalTest")?;
			}
			if !Vec::is_empty(&self.r#code) {
				serialize_struct.serialize_field("code", {
					struct SerializeWith<'a>(&'a Vec<CodeProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#code)
				})?;
			} else {
				serialize_struct.skip_field("code")?;
			}
			if !Vec::is_empty(&self.r#funding) {
				serialize_struct.serialize_field("funding", {
					struct SerializeWith<'a>(&'a Vec<FundingProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#funding)
				})?;
			} else {
				serialize_struct.skip_field("funding")?;
			}
			if !Vec::is_empty(&self.r#guideline) {
				serialize_struct.serialize_field("guideline", {
					struct SerializeWith<'a>(&'a Vec<GuidelineProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#guideline)
				})?;
			} else {
				serialize_struct.skip_field("guideline")?;
			}
			if !Vec::is_empty(&self.r#legal_status) {
				serialize_struct.serialize_field("legalStatus", {
					struct SerializeWith<'a>(&'a Vec<LegalStatusProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#legal_status)
				})?;
			} else {
				serialize_struct.skip_field("legalStatus")?;
			}
			if !Vec::is_empty(&self.r#medicine_system) {
				serialize_struct.serialize_field("medicineSystem", {
					struct SerializeWith<'a>(&'a Vec<MedicineSystemProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#medicine_system)
				})?;
			} else {
				serialize_struct.skip_field("medicineSystem")?;
			}
			if !Vec::is_empty(&self.r#recognizing_authority) {
				serialize_struct.serialize_field("recognizingAuthority", {
					struct SerializeWith<'a>(&'a Vec<RecognizingAuthorityProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#recognizing_authority)
				})?;
			} else {
				serialize_struct.skip_field("recognizingAuthority")?;
			}
			if !Vec::is_empty(&self.r#relevant_specialty) {
				serialize_struct.serialize_field("relevantSpecialty", {
					struct SerializeWith<'a>(&'a Vec<RelevantSpecialtyProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#relevant_specialty)
				})?;
			} else {
				serialize_struct.skip_field("relevantSpecialty")?;
			}
			if !Vec::is_empty(&self.r#study) {
				serialize_struct.serialize_field("study", {
					struct SerializeWith<'a>(&'a Vec<StudyProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#study)
				})?;
			} else {
				serialize_struct.skip_field("study")?;
			}
			if !Vec::is_empty(&self.r#additional_type) {
				serialize_struct.serialize_field("additionalType", {
					struct SerializeWith<'a>(&'a Vec<AdditionalTypeProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#additional_type)
				})?;
			} else {
				serialize_struct.skip_field("additionalType")?;
			}
			if !Vec::is_empty(&self.r#alternate_name) {
				serialize_struct.serialize_field("alternateName", {
					struct SerializeWith<'a>(&'a Vec<AlternateNameProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#alternate_name)
				})?;
			} else {
				serialize_struct.skip_field("alternateName")?;
			}
			if !Vec::is_empty(&self.r#description) {
				serialize_struct.serialize_field("description", {
					struct SerializeWith<'a>(&'a Vec<DescriptionProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#description)
				})?;
			} else {
				serialize_struct.skip_field("description")?;
			}
			if !Vec::is_empty(&self.r#disambiguating_description) {
				serialize_struct.serialize_field("disambiguatingDescription", {
					struct SerializeWith<'a>(&'a Vec<DisambiguatingDescriptionProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#disambiguating_description)
				})?;
			} else {
				serialize_struct.skip_field("disambiguatingDescription")?;
			}
			if !Vec::is_empty(&self.r#identifier) {
				serialize_struct.serialize_field("identifier", {
					struct SerializeWith<'a>(&'a Vec<IdentifierProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#identifier)
				})?;
			} else {
				serialize_struct.skip_field("identifier")?;
			}
			if !Vec::is_empty(&self.r#image) {
				serialize_struct.serialize_field("image", {
					struct SerializeWith<'a>(&'a Vec<ImageProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#image)
				})?;
			} else {
				serialize_struct.skip_field("image")?;
			}
			if !Vec::is_empty(&self.r#main_entity_of_page) {
				serialize_struct.serialize_field("mainEntityOfPage", {
					struct SerializeWith<'a>(&'a Vec<MainEntityOfPageProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#main_entity_of_page)
				})?;
			} else {
				serialize_struct.skip_field("mainEntityOfPage")?;
			}
			if !Vec::is_empty(&self.r#name) {
				serialize_struct.serialize_field("name", {
					struct SerializeWith<'a>(&'a Vec<NameProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#name)
				})?;
			} else {
				serialize_struct.skip_field("name")?;
			}
			if !Vec::is_empty(&self.r#potential_action) {
				serialize_struct.serialize_field("potentialAction", {
					struct SerializeWith<'a>(&'a Vec<PotentialActionProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#potential_action)
				})?;
			} else {
				serialize_struct.skip_field("potentialAction")?;
			}
			if !Vec::is_empty(&self.r#same_as) {
				serialize_struct.serialize_field("sameAs", {
					struct SerializeWith<'a>(&'a Vec<SameAsProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#same_as)
				})?;
			} else {
				serialize_struct.skip_field("sameAs")?;
			}
			if !Vec::is_empty(&self.r#subject_of) {
				serialize_struct.serialize_field("subjectOf", {
					struct SerializeWith<'a>(&'a Vec<SubjectOfProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#subject_of)
				})?;
			} else {
				serialize_struct.skip_field("subjectOf")?;
			}
			if !Vec::is_empty(&self.r#url) {
				serialize_struct.serialize_field("url", {
					struct SerializeWith<'a>(&'a Vec<UrlProperty>);
					impl<'a> Serialize for SerializeWith<'a> {
						fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
						where
							S: Serializer,
						{
							serde_with::As::<serde_with::OneOrMany<serde_with::Same>>::serialize(
								self.0, serializer,
							)
						}
					}
					&SerializeWith(&self.r#url)
				})?;
			} else {
				serialize_struct.skip_field("url")?;
			}
			serialize_struct.end()
		}
	}
	impl<'de> Deserialize<'de> for MedicalCondition {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: Deserializer<'de>,
		{
			enum Field {
				AssociatedAnatomy,
				DifferentialDiagnosis,
				Drug,
				Epidemiology,
				ExpectedPrognosis,
				NaturalProgression,
				Pathophysiology,
				PossibleComplication,
				PossibleTreatment,
				PrimaryPrevention,
				RiskFactor,
				SecondaryPrevention,
				SignOrSymptom,
				Stage,
				Status,
				TypicalTest,
				Code,
				Funding,
				Guideline,
				LegalStatus,
				MedicineSystem,
				RecognizingAuthority,
				RelevantSpecialty,
				Study,
				AdditionalType,
				AlternateName,
				Description,
				DisambiguatingDescription,
				Identifier,
				Image,
				MainEntityOfPage,
				Name,
				PotentialAction,
				SameAs,
				SubjectOf,
				Url,
			}
			struct FieldVisitor;
			impl<'de> Visitor<'de> for FieldVisitor {
				type Value = Field;
				fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
					formatter.write_str("field identifier")
				}
				fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
				where
					E: de::Error,
				{
					match value {
						"associatedAnatomy" => Ok(Field::AssociatedAnatomy),
						"differentialDiagnosis" => Ok(Field::DifferentialDiagnosis),
						"drug" => Ok(Field::Drug),
						"epidemiology" => Ok(Field::Epidemiology),
						"expectedPrognosis" => Ok(Field::ExpectedPrognosis),
						"naturalProgression" => Ok(Field::NaturalProgression),
						"pathophysiology" => Ok(Field::Pathophysiology),
						"possibleComplication" => Ok(Field::PossibleComplication),
						"possibleTreatment" => Ok(Field::PossibleTreatment),
						"primaryPrevention" => Ok(Field::PrimaryPrevention),
						"riskFactor" => Ok(Field::RiskFactor),
						"secondaryPrevention" => Ok(Field::SecondaryPrevention),
						"signOrSymptom" => Ok(Field::SignOrSymptom),
						"stage" => Ok(Field::Stage),
						"status" => Ok(Field::Status),
						"typicalTest" => Ok(Field::TypicalTest),
						"code" => Ok(Field::Code),
						"funding" => Ok(Field::Funding),
						"guideline" => Ok(Field::Guideline),
						"legalStatus" => Ok(Field::LegalStatus),
						"medicineSystem" => Ok(Field::MedicineSystem),
						"recognizingAuthority" => Ok(Field::RecognizingAuthority),
						"relevantSpecialty" => Ok(Field::RelevantSpecialty),
						"study" => Ok(Field::Study),
						"additionalType" => Ok(Field::AdditionalType),
						"alternateName" => Ok(Field::AlternateName),
						"description" => Ok(Field::Description),
						"disambiguatingDescription" => Ok(Field::DisambiguatingDescription),
						"identifier" => Ok(Field::Identifier),
						"image" => Ok(Field::Image),
						"mainEntityOfPage" => Ok(Field::MainEntityOfPage),
						"name" => Ok(Field::Name),
						"potentialAction" => Ok(Field::PotentialAction),
						"sameAs" => Ok(Field::SameAs),
						"subjectOf" => Ok(Field::SubjectOf),
						"url" => Ok(Field::Url),
						_ => Err(de::Error::unknown_field(value, FIELDS)),
					}
				}
				fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>
				where
					E: de::Error,
				{
					match value {
						b"associatedAnatomy" => Ok(Field::AssociatedAnatomy),
						b"differentialDiagnosis" => Ok(Field::DifferentialDiagnosis),
						b"drug" => Ok(Field::Drug),
						b"epidemiology" => Ok(Field::Epidemiology),
						b"expectedPrognosis" => Ok(Field::ExpectedPrognosis),
						b"naturalProgression" => Ok(Field::NaturalProgression),
						b"pathophysiology" => Ok(Field::Pathophysiology),
						b"possibleComplication" => Ok(Field::PossibleComplication),
						b"possibleTreatment" => Ok(Field::PossibleTreatment),
						b"primaryPrevention" => Ok(Field::PrimaryPrevention),
						b"riskFactor" => Ok(Field::RiskFactor),
						b"secondaryPrevention" => Ok(Field::SecondaryPrevention),
						b"signOrSymptom" => Ok(Field::SignOrSymptom),
						b"stage" => Ok(Field::Stage),
						b"status" => Ok(Field::Status),
						b"typicalTest" => Ok(Field::TypicalTest),
						b"code" => Ok(Field::Code),
						b"funding" => Ok(Field::Funding),
						b"guideline" => Ok(Field::Guideline),
						b"legalStatus" => Ok(Field::LegalStatus),
						b"medicineSystem" => Ok(Field::MedicineSystem),
						b"recognizingAuthority" => Ok(Field::RecognizingAuthority),
						b"relevantSpecialty" => Ok(Field::RelevantSpecialty),
						b"study" => Ok(Field::Study),
						b"additionalType" => Ok(Field::AdditionalType),
						b"alternateName" => Ok(Field::AlternateName),
						b"description" => Ok(Field::Description),
						b"disambiguatingDescription" => Ok(Field::DisambiguatingDescription),
						b"identifier" => Ok(Field::Identifier),
						b"image" => Ok(Field::Image),
						b"mainEntityOfPage" => Ok(Field::MainEntityOfPage),
						b"name" => Ok(Field::Name),
						b"potentialAction" => Ok(Field::PotentialAction),
						b"sameAs" => Ok(Field::SameAs),
						b"subjectOf" => Ok(Field::SubjectOf),
						b"url" => Ok(Field::Url),
						_ => {
							let value = &String::from_utf8_lossy(value);
							Err(de::Error::unknown_field(value, FIELDS))
						}
					}
				}
			}
			impl<'de> Deserialize<'de> for Field {
				fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
				where
					D: Deserializer<'de>,
				{
					deserializer.deserialize_identifier(FieldVisitor)
				}
			}
			struct ClassVisitor;
			impl<'de> Visitor<'de> for ClassVisitor {
				type Value = MedicalCondition;
				fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
					formatter.write_str("schema.org schema MedicalCondition")
				}
				fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
				where
					A: de::MapAccess<'de>,
				{
					let mut r#associated_anatomy_property = None;
					let mut r#differential_diagnosis_property = None;
					let mut r#drug_property = None;
					let mut r#epidemiology_property = None;
					let mut r#expected_prognosis_property = None;
					let mut r#natural_progression_property = None;
					let mut r#pathophysiology_property = None;
					let mut r#possible_complication_property = None;
					let mut r#possible_treatment_property = None;
					let mut r#primary_prevention_property = None;
					let mut r#risk_factor_property = None;
					let mut r#secondary_prevention_property = None;
					let mut r#sign_or_symptom_property = None;
					let mut r#stage_property = None;
					let mut r#status_property = None;
					let mut r#typical_test_property = None;
					let mut r#code_property = None;
					let mut r#funding_property = None;
					let mut r#guideline_property = None;
					let mut r#legal_status_property = None;
					let mut r#medicine_system_property = None;
					let mut r#recognizing_authority_property = None;
					let mut r#relevant_specialty_property = None;
					let mut r#study_property = None;
					let mut r#additional_type_property = None;
					let mut r#alternate_name_property = None;
					let mut r#description_property = None;
					let mut r#disambiguating_description_property = None;
					let mut r#identifier_property = None;
					let mut r#image_property = None;
					let mut r#main_entity_of_page_property = None;
					let mut r#name_property = None;
					let mut r#potential_action_property = None;
					let mut r#same_as_property = None;
					let mut r#subject_of_property = None;
					let mut r#url_property = None;
					while let Some(key) = map.next_key::<Field>()? {
						match key {
							Field::AssociatedAnatomy => {
								if r#associated_anatomy_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"associatedAnatomy",
									));
								}
								r#associated_anatomy_property = Some({
									struct DeserializeWith(Vec<AssociatedAnatomyProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::DifferentialDiagnosis => {
								if r#differential_diagnosis_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"differentialDiagnosis",
									));
								}
								r#differential_diagnosis_property = Some({
									struct DeserializeWith(Vec<DifferentialDiagnosisProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::Drug => {
								if r#drug_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field("drug"));
								}
								r#drug_property = Some({
									struct DeserializeWith(Vec<DrugProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::Epidemiology => {
								if r#epidemiology_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"epidemiology",
									));
								}
								r#epidemiology_property = Some({
									struct DeserializeWith(Vec<EpidemiologyProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::ExpectedPrognosis => {
								if r#expected_prognosis_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"expectedPrognosis",
									));
								}
								r#expected_prognosis_property = Some({
									struct DeserializeWith(Vec<ExpectedPrognosisProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::NaturalProgression => {
								if r#natural_progression_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"naturalProgression",
									));
								}
								r#natural_progression_property = Some({
									struct DeserializeWith(Vec<NaturalProgressionProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::Pathophysiology => {
								if r#pathophysiology_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"pathophysiology",
									));
								}
								r#pathophysiology_property = Some({
									struct DeserializeWith(Vec<PathophysiologyProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::PossibleComplication => {
								if r#possible_complication_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"possibleComplication",
									));
								}
								r#possible_complication_property = Some({
									struct DeserializeWith(Vec<PossibleComplicationProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::PossibleTreatment => {
								if r#possible_treatment_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"possibleTreatment",
									));
								}
								r#possible_treatment_property = Some({
									struct DeserializeWith(Vec<PossibleTreatmentProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::PrimaryPrevention => {
								if r#primary_prevention_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"primaryPrevention",
									));
								}
								r#primary_prevention_property = Some({
									struct DeserializeWith(Vec<PrimaryPreventionProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::RiskFactor => {
								if r#risk_factor_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"riskFactor",
									));
								}
								r#risk_factor_property = Some({
									struct DeserializeWith(Vec<RiskFactorProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::SecondaryPrevention => {
								if r#secondary_prevention_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"secondaryPrevention",
									));
								}
								r#secondary_prevention_property = Some({
									struct DeserializeWith(Vec<SecondaryPreventionProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::SignOrSymptom => {
								if r#sign_or_symptom_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"signOrSymptom",
									));
								}
								r#sign_or_symptom_property = Some({
									struct DeserializeWith(Vec<SignOrSymptomProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::Stage => {
								if r#stage_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field("stage"));
								}
								r#stage_property = Some({
									struct DeserializeWith(Vec<StageProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::Status => {
								if r#status_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field("status"));
								}
								r#status_property = Some({
									struct DeserializeWith(Vec<StatusProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::TypicalTest => {
								if r#typical_test_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"typicalTest",
									));
								}
								r#typical_test_property = Some({
									struct DeserializeWith(Vec<TypicalTestProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::Code => {
								if r#code_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field("code"));
								}
								r#code_property = Some({
									struct DeserializeWith(Vec<CodeProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::Funding => {
								if r#funding_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"funding",
									));
								}
								r#funding_property = Some({
									struct DeserializeWith(Vec<FundingProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::Guideline => {
								if r#guideline_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"guideline",
									));
								}
								r#guideline_property = Some({
									struct DeserializeWith(Vec<GuidelineProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::LegalStatus => {
								if r#legal_status_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"legalStatus",
									));
								}
								r#legal_status_property = Some({
									struct DeserializeWith(Vec<LegalStatusProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::MedicineSystem => {
								if r#medicine_system_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"medicineSystem",
									));
								}
								r#medicine_system_property = Some({
									struct DeserializeWith(Vec<MedicineSystemProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::RecognizingAuthority => {
								if r#recognizing_authority_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"recognizingAuthority",
									));
								}
								r#recognizing_authority_property = Some({
									struct DeserializeWith(Vec<RecognizingAuthorityProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::RelevantSpecialty => {
								if r#relevant_specialty_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"relevantSpecialty",
									));
								}
								r#relevant_specialty_property = Some({
									struct DeserializeWith(Vec<RelevantSpecialtyProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::Study => {
								if r#study_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field("study"));
								}
								r#study_property = Some({
									struct DeserializeWith(Vec<StudyProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::AdditionalType => {
								if r#additional_type_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"additionalType",
									));
								}
								r#additional_type_property = Some({
									struct DeserializeWith(Vec<AdditionalTypeProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::AlternateName => {
								if r#alternate_name_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"alternateName",
									));
								}
								r#alternate_name_property = Some({
									struct DeserializeWith(Vec<AlternateNameProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::Description => {
								if r#description_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"description",
									));
								}
								r#description_property = Some({
									struct DeserializeWith(Vec<DescriptionProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::DisambiguatingDescription => {
								if r#disambiguating_description_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"disambiguatingDescription",
									));
								}
								r#disambiguating_description_property = Some({
									struct DeserializeWith(Vec<DisambiguatingDescriptionProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::Identifier => {
								if r#identifier_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"identifier",
									));
								}
								r#identifier_property = Some({
									struct DeserializeWith(Vec<IdentifierProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::Image => {
								if r#image_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field("image"));
								}
								r#image_property = Some({
									struct DeserializeWith(Vec<ImageProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::MainEntityOfPage => {
								if r#main_entity_of_page_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"mainEntityOfPage",
									));
								}
								r#main_entity_of_page_property = Some({
									struct DeserializeWith(Vec<MainEntityOfPageProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::Name => {
								if r#name_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field("name"));
								}
								r#name_property = Some({
									struct DeserializeWith(Vec<NameProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::PotentialAction => {
								if r#potential_action_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"potentialAction",
									));
								}
								r#potential_action_property = Some({
									struct DeserializeWith(Vec<PotentialActionProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::SameAs => {
								if r#same_as_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field("sameAs"));
								}
								r#same_as_property = Some({
									struct DeserializeWith(Vec<SameAsProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::SubjectOf => {
								if r#subject_of_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field(
										"subjectOf",
									));
								}
								r#subject_of_property = Some({
									struct DeserializeWith(Vec<SubjectOfProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
							Field::Url => {
								if r#url_property.is_some() {
									return Err(<A::Error as de::Error>::duplicate_field("url"));
								}
								r#url_property = Some({
									struct DeserializeWith(Vec<UrlProperty>);
									impl<'de> Deserialize<'de> for DeserializeWith {
										fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
										where
											D: Deserializer<'de>,
										{
											Ok(DeserializeWith(serde_with::As::<
												serde_with::OneOrMany<serde_with::Same>,
											>::deserialize(deserializer)?))
										}
									}
									match map.next_value::<DeserializeWith>() {
										Ok(deserialize_with) => deserialize_with.0,
										Err(err) => {
											return Err(err);
										}
									}
								});
							}
						}
					}
					Ok(MedicalCondition {
						r#associated_anatomy: r#associated_anatomy_property.unwrap_or_default(),
						r#differential_diagnosis: r#differential_diagnosis_property
							.unwrap_or_default(),
						r#drug: r#drug_property.unwrap_or_default(),
						r#epidemiology: r#epidemiology_property.unwrap_or_default(),
						r#expected_prognosis: r#expected_prognosis_property.unwrap_or_default(),
						r#natural_progression: r#natural_progression_property.unwrap_or_default(),
						r#pathophysiology: r#pathophysiology_property.unwrap_or_default(),
						r#possible_complication: r#possible_complication_property
							.unwrap_or_default(),
						r#possible_treatment: r#possible_treatment_property.unwrap_or_default(),
						r#primary_prevention: r#primary_prevention_property.unwrap_or_default(),
						r#risk_factor: r#risk_factor_property.unwrap_or_default(),
						r#secondary_prevention: r#secondary_prevention_property.unwrap_or_default(),
						r#sign_or_symptom: r#sign_or_symptom_property.unwrap_or_default(),
						r#stage: r#stage_property.unwrap_or_default(),
						r#status: r#status_property.unwrap_or_default(),
						r#typical_test: r#typical_test_property.unwrap_or_default(),
						r#code: r#code_property.unwrap_or_default(),
						r#funding: r#funding_property.unwrap_or_default(),
						r#guideline: r#guideline_property.unwrap_or_default(),
						r#legal_status: r#legal_status_property.unwrap_or_default(),
						r#medicine_system: r#medicine_system_property.unwrap_or_default(),
						r#recognizing_authority: r#recognizing_authority_property
							.unwrap_or_default(),
						r#relevant_specialty: r#relevant_specialty_property.unwrap_or_default(),
						r#study: r#study_property.unwrap_or_default(),
						r#additional_type: r#additional_type_property.unwrap_or_default(),
						r#alternate_name: r#alternate_name_property.unwrap_or_default(),
						r#description: r#description_property.unwrap_or_default(),
						r#disambiguating_description: r#disambiguating_description_property
							.unwrap_or_default(),
						r#identifier: r#identifier_property.unwrap_or_default(),
						r#image: r#image_property.unwrap_or_default(),
						r#main_entity_of_page: r#main_entity_of_page_property.unwrap_or_default(),
						r#name: r#name_property.unwrap_or_default(),
						r#potential_action: r#potential_action_property.unwrap_or_default(),
						r#same_as: r#same_as_property.unwrap_or_default(),
						r#subject_of: r#subject_of_property.unwrap_or_default(),
						r#url: r#url_property.unwrap_or_default(),
					})
				}
			}
			const FIELDS: &[&str] = &[
				"associatedAnatomy",
				"differentialDiagnosis",
				"drug",
				"epidemiology",
				"expectedPrognosis",
				"naturalProgression",
				"pathophysiology",
				"possibleComplication",
				"possibleTreatment",
				"primaryPrevention",
				"riskFactor",
				"secondaryPrevention",
				"signOrSymptom",
				"stage",
				"status",
				"typicalTest",
				"code",
				"funding",
				"guideline",
				"legalStatus",
				"medicineSystem",
				"recognizingAuthority",
				"relevantSpecialty",
				"study",
				"additionalType",
				"alternateName",
				"description",
				"disambiguatingDescription",
				"identifier",
				"image",
				"mainEntityOfPage",
				"name",
				"potentialAction",
				"sameAs",
				"subjectOf",
				"url",
			];
			deserializer.deserialize_struct("MedicalCondition", FIELDS, ClassVisitor)
		}
	}
}
